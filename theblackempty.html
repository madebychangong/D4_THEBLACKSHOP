<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>THE BLACK 템플릿</title>
  <style>
    @font-face {
      font-family: 'Pretendard';
      src: url('./fonts/Pretendard-Regular.woff2') format('woff2'),
           url('./fonts/Pretendard-Regular.woff') format('woff');
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: 'Pretendard';
      src: url('./fonts/Pretendard-Bold.woff2') format('woff2'),
           url('./fonts/Pretendard-Bold.woff') format('woff');
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }
    html, body {
      margin: 0; padding: 0;
      background: linear-gradient(135deg, 
        #1a1a2e 0%, 
        #16213e 25%, 
        #0f3460 50%, 
        #533483 75%, 
        #1a1a2e 100%);
      color: #fff;
      font-family: 'Pretendard', Arial, sans-serif;
      box-sizing: border-box;
      min-height: 100vh;
    }
    .render-target {
      width: 600px;
      margin: 40px auto 0 auto;
      background: rgba(0, 0, 0, 0.15);
      backdrop-filter: blur(20px);
      border-radius: 24px;
      padding: 40px 42px 36px 42px;
      text-align: center;
      position: relative;
      height: auto;
      border: 1px solid rgba(255, 255, 255, 0.1);
      box-shadow: 
        0 8px 32px rgba(0, 0, 0, 0.3),
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -1px 0 rgba(255, 255, 255, 0.05);
    }
    .render-target::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, 
        rgba(255, 255, 255, 0.1) 0%, 
        rgba(255, 255, 255, 0.05) 25%, 
        rgba(255, 255, 255, 0.02) 50%, 
        rgba(255, 255, 255, 0.05) 75%, 
        rgba(255, 255, 255, 0.1) 100%);
      border-radius: 24px;
      pointer-events: none;
    }

    /* === 캡쳐 전용 스킨 === */
    .render-target.capture-polish {
      border: none !important;
      box-shadow:
        0 0 0 1px rgba(255,255,255,0.08),
        0 18px 40px rgba(0,0,0,0.55),
        0 6px 16px rgba(0,0,0,0.35) !important;
      background: #0f1117 !important;
      backdrop-filter: none !important;
    }
    .render-target.capture-polish::before {
      display: none !important;
    }
    .render-target.capture-polish .description {
      border: none !important;
      box-shadow: none !important;
      background: rgba(255,255,255,0.04) !important;
    }
    .render-target.capture-polish .divider,
    .render-target.capture-polish .subtitle-divider {
      border-top-color: transparent !important;
    }

    .shop-title {
      color: #ffe85c;
      font-size: 36px;
      font-weight: 700;
      margin-bottom: 10px;
      margin-top: 0;
      letter-spacing: 2.5px;
      white-space: normal;
      text-align: center;
      line-height: 1.2;
      text-shadow: 
        0 0 10px rgba(255, 232, 92, 0.5),
        0 2px 4px rgba(0, 0, 0, 0.3);
      position: relative;
      z-index: 1;
    }
    .shop-title .icon {
      font-size: 40px;
      vertical-align: middle;
    }
    .shop-subtitle {
      color: rgba(255, 255, 255, 0.8);
      font-size: 20px;
      margin-bottom: 30px;
      font-weight: 400;
      letter-spacing: 0.8px;
      text-align: center;
      position: relative;
      z-index: 1;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    .divider, .subtitle-divider {
      border: none;
      border-top: 1px solid rgba(255, 255, 255, 0.15);
      margin: 1px 0 1px 0;
      position: relative;
      z-index: 1;
    }
    .info-list {
      margin: 0 0 0px 0;
      padding: 0;
      list-style: none;
      font-size: 22px;
      font-weight: 400;
      text-align: center;
      position: relative;
      z-index: 1;
    }
    .info-list li {
      display: block !important;
      white-space: normal !important;
      word-break: break-word !important;
      overflow-wrap: break-word !important;
      margin: 6px 0;
      line-height: 1.65;
      color: rgba(255, 255, 255, 0.9);
      letter-spacing: 0.3px;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
    }
    .info-list li .icon {
      font-size: 21px;
      margin-right: 10px;
      vertical-align: middle;
    }
    .cta-btn {
      margin: 18px auto 22px auto;
      background: linear-gradient(135deg, #1affeb 0%, #0ee5d0 100%);
      color: #0a0a0a;
      font-weight: 900;
      font-size: 23px;
      padding: 14px 40px 14px 40px;
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      display: inline-block;
      box-shadow: 
        0 4px 16px rgba(26, 255, 235, 0.3),
        0 2px 4px rgba(0, 0, 0, 0.1),
        inset 0 1px 0 rgba(255, 255, 255, 0.3);
      cursor: default;
      pointer-events: none;
      text-decoration: none;
      text-align: center;
      font-family: 'Pretendard', Arial, sans-serif;
      letter-spacing: 0.5px;
      position: relative;
      z-index: 1;
    }
    .section-price-title {
      font-size: 32px;
      color: #3dffb8;
      font-weight: 900;
      margin-bottom: 20px;
      margin-top: 0;
      letter-spacing: 1.2px;
      text-align: center;
      font-family: 'Pretendard', Arial, sans-serif;
      text-shadow: 
        0 0 10px rgba(61, 255, 184, 0.4),
        0 2px 4px rgba(0, 0, 0, 0.3);
      position: relative;
      z-index: 1;
    }
    .description {
      font-size: 18px;
      color: rgba(255, 255, 255, 0.85);
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      padding: 20px;
      text-align: center;
      font-weight: 500;
      white-space: pre-wrap;
      margin: 0;
      min-height: 60px;
      line-height: 1.75;
      letter-spacing: 0.6px;
      font-family: 'Pretendard', Arial, sans-serif;
      position: relative;
      z-index: 1;
      backdrop-filter: blur(10px);
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
    }

    /* === 가격표 컨테이너 === */
    #priceContainer {
      position: relative;
    }
  </style>
  <!-- 순서 매우 중요!! -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js"></script>
</head>
<body>

  <div class="render-target" id="capture">
    <div>
      <h1 class="shop-title">
        <span class="icon">🦇</span> THE BLACK SHOP <span class="icon">🧛‍♂️</span>
      </h1>
      <div class="shop-subtitle">디아블로4 시즌10 버스 · 대리 · 아이템 전문 거래소</div>
      <hr class="subtitle-divider" />
    </div>

    <ul class="info-list">
      <li><span class="icon">🦾</span>모든 장비, 아이템, 재료 완비</li>
      <li><span class="icon">🚌</span>버스, 대리, 세팅 풀 지원</li>
      <li><span class="icon">🦸‍♂️</span>경험 많은 전문 기사 상시 대기</li>
      <li><span class="icon">🔥</span>합리적인 실시간 최저가 보장</li>
    </ul>
    <div class="cta-btn">
      💬 오픈채팅은 가격표 클릭!
    </div>
    <hr class="divider" />
    <div>
      <h2 class="section-price-title">💰 실시간 가격표</h2>
    </div>

    <!-- 가격표 영역 (경고 배너 제거 버전) -->
    <div id="priceContainer"></div>
  </div>

  <script>
    document.addEventListener("DOMContentLoaded", () => {
      // 파라미터 읽기
      const params = new URLSearchParams(window.location.search);
      const userId = params.get("uid");
      const mainTextParam = params.get("mainText");
      let mainTextLoaded = false;

      // 🔹 (추가) 단일 링크 파라미터: 없으면 기본값 사용
      const chatUrl = params.get("chat") || "https://open.kakao.com/o/somechat";
      // === THE BLACK 태그 스타일 설정 (색상/자간/줄간격 변경은 여기서) ===
      const TB_TAG = {
        colorMode: 'random', // 'random' | 'fixed'
        fixedColor: '#00FFD5',
        palette: ['#00FFD5', '#FFD166', '#FF6B6B', '#7C5CFF', '#7CF17F', '#56C0FF', '#FF9F43', '#F72585', '#4CC9F0', '#B9FBC0'],
        letterSpacing: '0.0px',   // 자간
        lineHeight: '1.35',       // 줄간격
        fontWeight: 800
      };



// === 구분선 대체 삽입 + 색상/자간 커스터마이즈 + 안전 HTML ===
function insertChatLinks(text, chatUrl) {
  const escapeHTML = (s) => s.replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
  const pickColor = (i) => TB_TAG.colorMode === 'fixed' ? TB_TAG.fixedColor : TB_TAG.palette[i % TB_TAG.palette.length];

  // 1) 실제 구분선 토큰화 (---, ***, ===, ___, ───, ━━━, ———, －－－, ＿＿＿, ㅡㅡㅡ 등)
  const dividerClass = "[\-\*=~_─━—–－＿ㅡ]";
  const splitRe = new RegExp(`(${dividerClass}{3,})`, 'g');
  const tokens = text.split(splitRe); // [seg0, div1, seg1, div2, seg2, ...]
  const dividerIdxs = [];
  for (let i = 1; i < tokens.length; i += 2) dividerIdxs.push(i);

  // 2) 교체할 구분선 3곳 선택 (1/4, 1/2, 3/4 지점 근처)
  let chosen = [];
  if (dividerIdxs.length > 0) {
    const candidates = [
      Math.floor(dividerIdxs.length / 4),
      Math.floor(dividerIdxs.length / 2),
      Math.floor(3 * dividerIdxs.length / 4)
    ];
    const seen = new Set();
    chosen = candidates
      .map(ix => dividerIdxs[Math.max(0, Math.min(dividerIdxs.length - 1, ix))])
      .filter(i => Number.isInteger(i) && !seen.has(i) && (seen.add(i), true));
  }

  // 3) 구분선이 0~2개뿐이면: 가능한 만큼만 대체하고, 부족분은 덩어리 사이에 추가
  let extraNeeded = Math.max(0, 3 - chosen.length);

  // 4) 태그 HTML 생성기 (색상/자간/줄간격 반영)
  let tagCount = 0;
  const makeTag = () => {
    const color = pickColor(tagCount++);
    const leftText = '#디아블로4 THEBLACK 오픈채팅링크확인 → ';
    return `<div class="tb-tagline" style="
      margin:6px 0;
      font-weight:${TB_TAG.fontWeight};
      letter-spacing:${TB_TAG.letterSpacing};
      line-height:${TB_TAG.lineHeight};
      color:${color};
      text-shadow:0 0 6px rgba(0,0,0,.35);
    ">${escapeHTML(leftText)}<span style="color:${color}; text-decoration:underline;">${escapeHTML(chatUrl)}</span></div>`;
  };

  // 5) HTML로 재조립
  let html = '';
  for (let i = 0; i < tokens.length; i++) {
    const isDivider = (i % 2 === 1);
    if (!isDivider) {
      html += escapeHTML(tokens[i]); // 본문은 전부 escape
      continue;
    }
    if (chosen.includes(i)) {
      // 선택된 구분선은 태그로 대체
      html += `
${makeTag()}
`;
    } else {
      // 그 외 구분선은 보기 좋게 유지
      html += `
${escapeHTML(tokens[i])}
`;
    }
  }

  // 6) 구분선 자체가 거의 없을 때 부족분 추가
  while (extraNeeded-- > 0) {
    html += `
-----------------------------------------
${makeTag()}
`;
  }

  return html;
}
\n`;

  // 1) 어떤 '대시류' 구분선이 와도 자르는 범용 패턴 (3개 이상 연속)
  //    포함 문자: -, *, =, ~, _, ─, ━, —, – , －(전각), ＿(전각), ㅡ(한글 기호)
  const dividerClass = "[\\-\\*=~_─━—–－＿ㅡ]";
  const anyDividerRE = new RegExp(`\\s*${dividerClass}{3,}\\s*`, "g");

  // 2) 구분선으로 1차 분할 (길이가 제각각이어도 OK)
  let parts = text.split(anyDividerRE);

  // 3) 구분선이 전혀 없을 때는 줄 기준으로 대체 분할
  if (parts.length < 2) {
    const lines = text.split(/\r?\n/);
    // 줄 수가 적으면 그냥 원문 한 덩어리 취급
    if (lines.length < 6) {
      // 최소 보장: 본문 뒤에 3회 삽입
      return text + `\n\n${tagLine}\n${tagLine}\n${tagLine}`;
    }
    // 줄을 3~4등분 지점에서 분할
    const p1 = Math.floor(lines.length / 4);
    const p2 = Math.floor(lines.length / 2);
    const p3 = Math.floor((3 * lines.length) / 4);
    const chunks = [
      lines.slice(0, p1).join("\n"),
      lines.slice(p1, p2).join("\n"),
      lines.slice(p2, p3).join("\n"),
      lines.slice(p3).join("\n"),
    ];
    parts = chunks;
  }

  // 4) 삽입 위치 계산 (가능하면 1/4, 1/2, 3/4 지점)
  let positions = [];
  if (parts.length >= 4) {
    positions = [
      Math.floor(parts.length / 4),
      Math.floor(parts.length / 2),
      Math.floor((3 * parts.length) / 4),
    ];
    // 유효/중복 제거
    const seen = new Set();
    positions = positions.filter(
      (i) => i > 0 && i < parts.length && !seen.has(i) && (seen.add(i), true)
    );
  } else {
    // 덩어리가 적을 때: 가능한 범위에서 최대 3회
    const step = Math.max(1, Math.floor(parts.length / 3));
    for (let i = step; i < parts.length && positions.length < 3; i += step) {
      if (i > 0 && i < parts.length) positions.push(i);
    }
  }

  // 5) 재합성 (구분선은 보기 좋게 긴 하이픈으로 통일)
  const rebuiltDivider = "\n-----------------------------------------\n";
  positions.sort((a, b) => a - b);
  for (let k = positions.length - 1; k >= 0; k--) {
    const idx = positions[k];
    parts[idx] = parts[idx].trim() + rebuiltDivider + tagLine;
  }
  return parts.join(rebuiltDivider);
}

      // 가격표 렌더(경고/리본 없이 단일 박스)
      function renderPrice(text) {
        const container = document.getElementById('priceContainer');
        container.innerHTML = '';
        const descDiv = document.createElement('div');
        descDiv.className = 'description';
        // (변경) 텍스트에 링크 3곳 자동 삽입
        descDiv.innerHTML = insertChatLinks(text || '', chatUrl);
        container.appendChild(descDiv);
      }

      // mainText 파라미터 있으면 바로 적용
      if (mainTextParam) {
        const decodedText = decodeURIComponent(mainTextParam);
        renderPrice(decodedText);
        mainTextLoaded = true;
      } else if (userId) {
        // Supabase 초기화
        const supabaseUrl = 'https://ssnmitgehgzzcpmqwhzt.supabase.co';
        const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNzbm1pdGdlaGd6emNwbXF3aHp0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTMzNjI1MDgsImV4cCI6MjA2ODkzODUwOH0.u3FrSDh5qYeccQmn0PkOs4nfqIhXLSFHhpWj2JXhTrA';
        const supabase = window.supabase.createClient(supabaseUrl, supabaseKey);

        (async function loadText() {
          const { data, error } = await supabase
            .from('user_texts')
            .select('main_text')
            .eq('user_id', userId)
            .order('created_at', { ascending: false })
            .limit(1);

          if (!error && data && data.length > 0) {
            renderPrice(data[0].main_text);
          } else {
            renderPrice('');
          }
          mainTextLoaded = true;
        })();
      } else {
        renderPrice('');
        mainTextLoaded = true;
      }

      // IFRAME 메시지(캡처 요청) 핸들러
      window.addEventListener('message', async (event) => {
        if (event.data?.type === 'IFRAME_READY') {
          // mainText 적용 완료까지 최대 2초 대기
          let waitCount = 0;
          while (!mainTextLoaded && waitCount < 100) {
            await new Promise(res => setTimeout(res, 20));
            waitCount++;
          }
          if (document.fonts && document.fonts.ready) {
            await document.fonts.ready;
          }
          captureAndSend();
        }
      });

      function captureAndSend() {
        const target = document.querySelector('.render-target');
        if (!target) {
          console.error('.render-target 요소를 찾을 수 없습니다.');
          return;
        }

        // 캡쳐용 스킨 적용
        target.classList.add('capture-polish');

        // 스타일 페인트 완료 이후 캡쳐
        requestAnimationFrame(() => {
          html2canvas(target, {
            useCORS: true,
            allowTaint: true,
            backgroundColor: null,
            scale: Math.max(2, window.devicePixelRatio),
            logging: false,
            removeContainer: true
          }).then((canvas) => {
            // 새 캔버스 생성하고 배경색 먼저 그리기
            const finalCanvas = document.createElement('canvas');
            finalCanvas.width = canvas.width;
            finalCanvas.height = canvas.height;
            const ctx = finalCanvas.getContext('2d');
            
            // 배경색 채우기
            ctx.fillStyle = '#0f1117';
            ctx.fillRect(0, 0, finalCanvas.width, finalCanvas.height);
            
            // 원본 이미지 위에 그리기
            ctx.drawImage(canvas, 0, 0);
            
            const imgData = finalCanvas.toDataURL('image/png');
            parent.postMessage({ type: 'CAPTURE_DONE', dataUrl: imgData }, '*');
          }).finally(() => {
            target.classList.remove('capture-polish');
          });
        });
      }
    });
  </script>

</body>
</html>
